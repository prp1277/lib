[Source](https://www.lynda.com/GraphQL-tutorials/GraphQL-overview)

# 1 Set-up and Instructions

## Requirements and Overview
To be able to make graph QL queries you need to define a schema which defines the query type and resolver for each api input. So type definition provides what type of data we expect and the resolver gets the data for us. So we'll get started by defining our friend's type for application and then resolve it with fake data for now. Alright! So the first thing, let's go in the schema.js. So if you don't have it open just click on schema.js here and we'll change a little bit of our schema. 

So the first thing I want to do is keep the type query but change the hello to friend and then we expect to return a Friend, but right now if we do that it's not going to work because we haven't defined what a friend type is yet. So let's go ahead and do that! So, the type Friend and we use the same approach as our query. Takes an id We also need to have our first name which we expect the String, we'll do the last name again for String and gender will expect a String for now. 

We'll change that in a couple of videos. Language will expect also String. So right now we only have Strings. We may have different types as we go through all those different types. But you have string. You have number. You have bullion. And you have many others that we'll explore as we go through the course. And the last one is an email which is also a String, okay? So that is pretty much it for our schema so make sure you save it. 

Then let's go in the index and update the index as well. Because right now we're resolving hello so if we were to do the query with friend and returning a Friend then this wouldn't work. It would actually throw us an error. The type doesn't match the resolver. So we need to change this. So right now what we'll do is change hello to friend, like so. And let's completely remove this and we'll create an object like so and in this object we'll return what we'll just do here so we'll basically resolve each field that we created in our schema. 

So if you take a look we have id, first name, last name, gender, language, email so we need to have all these here. So for an id let's just do a fictive number. This is all fake data but eventually we'll have real data as we get our persistence set up. So the first name will have Manny Last name, you want to make sure that your syntax matches exactly what the types are. So if you do something like this, first name and then your type has a first name with a capital N here that wouldn't work. 

So you want to make sure that your types matches exactly what you're resolving in this function. So the last name is Henri. Then gender, let's do male. Language, english and email me@me.com And don't try to email me at this email. 

It won't work. Okay. So we don't change anything else so the schema is basically the same. The rootValue stays the same. Everything else stays the same so let's save that. And let's open up our terminal to make sure our server is running. So our changes already refreshed the server. Let's go inside of graphiQL here and test this. So right now let's refresh graphiQL. 

I'm just going to manually re-enter the local host, 8080 graphQL. M'kay. So if I'm running this, I'm going to have an error. So this is no longer existing in the server. So if you take a look at the documentation explorer basically gives you what type of queries you can do. So if we take a look at the queries that we can do So you can click here and it tells you that we can do a query called friend and it will return a Friend. So these are things that we can call when we do a query under friend. 

So let's go ahead and change that, so as I've said in the past when you start entering things in graphiQL, it's going to recommend what you can do here. So let's say for example I do a query and then my query is friend. Then I can start typing what kind of data I want to return from the friend so I can basically get the id. I can get the first name. And the last name. So this is how you do a query in graphiQL or graphQL. 

So you do the query here. You define what is the query that you're calling. So again if we go back here this is the type of query we can do and it will return a friend and if we go back to our code this is pretty much what we've defined here. So we can do a friend query and it will return a Friend and then these are the types of properties that you can call on graphQL. So you can call anything you want and it will return only that information and not anything else. 

So if I'm not calling the last name it's not going to return the last name. So if we were to run this particular query it gives me what we've actually coded in the resolver. So it gives me the id that I've coded, first name, last name. So if I just wanted to have the gender I could actually just call the gender like so, and I will get the male. And so on so forth. So this is how you make queries, simple queries in graphQL. One of the things that is really cool about graphiQL is that you can get an history of all the queries and mutations that we're going to do down the road, that you've done. 

So if you want to repeat the same thing again you can simply click on the queries that you've done. So if I ran hello again it's not going to work. If I ran the first query that I've done for the new code then this is going to return what I've done in the past. And so on and so forth. So as you start adding mutations you're going to see all the history of your queries and mutations here and you can actually star them as well. So you can always go back and do this a lot faster. There's also another function that you can use here which is called prettify which will basically make your query a lot cleaner and still run successfully the same thing. 

So as you can see it's pretty straight forward to build your schema and then run queries only on what you need. So let's move on. 

## Setting up an ES6 Server
To be able to make graph QL queries you need to define a schema which defines the query type and resolver for each api input. So type definition provides what type of data we expect and the resolver gets the data for us. So we'll get started by defining our friend's type for application and then resolve it with fake data for now. Alright! So the first thing, let's go in the schema.js. So if you don't have it open just click on schema.js here and we'll change a little bit of our schema. 

So the first thing I want to do is keep the type query but change the hello to friend and then we expect to return a Friend, but right now if we do that it's not going to work because we haven't defined what a friend type is yet. So let's go ahead and do that! So, the type Friend and we use the same approach as our query. Takes an id We also need to have our first name which we expect the String, we'll do the last name again for String and gender will expect a String for now. 

We'll change that in a couple of videos. Language will expect also String. So right now we only have Strings. We may have different types as we go through all those different types. But you have string. You have number. You have bullion. And you have many others that we'll explore as we go through the course. And the last one is an email which is also a String, okay? So that is pretty much it for our schema so make sure you save it. 

Then let's go in the index and update the index as well. Because right now we're resolving hello so if we were to do the query with friend and returning a Friend then this wouldn't work. It would actually throw us an error. The type doesn't match the resolver. So we need to change this. So right now what we'll do is change hello to friend, like so. And let's completely remove this and we'll create an object like so and in this object we'll return what we'll just do here so we'll basically resolve each field that we created in our schema. 

So if you take a look we have id, first name, last name, gender, language, email so we need to have all these here. So for an id let's just do a fictive number. This is all fake data but eventually we'll have real data as we get our persistence set up. So the first name will have Manny Last name, you want to make sure that your syntax matches exactly what the types are. So if you do something like this, first name and then your type has a first name with a capital N here that wouldn't work. 

So you want to make sure that your types matches exactly what you're resolving in this function. So the last name is Henri. Then gender, let's do male. Language, english and email me@me.com And don't try to email me at this email. 

It won't work. Okay. So we don't change anything else so the schema is basically the same. The rootValue stays the same. Everything else stays the same so let's save that. And let's open up our terminal to make sure our server is running. So our changes already refreshed the server. Let's go inside of graphiQL here and test this. So right now let's refresh graphiQL. 

I'm just going to manually re-enter the local host, 8080 graphQL. M'kay. So if I'm running this, I'm going to have an error. So this is no longer existing in the server. So if you take a look at the documentation explorer basically gives you what type of queries you can do. So if we take a look at the queries that we can do So you can click here and it tells you that we can do a query called friend and it will return a Friend. So these are things that we can call when we do a query under friend. 

So let's go ahead and change that, so as I've said in the past when you start entering things in graphiQL, it's going to recommend what you can do here. So let's say for example I do a query and then my query is friend. Then I can start typing what kind of data I want to return from the friend so I can basically get the id. I can get the first name. And the last name. So this is how you do a query in graphiQL or graphQL. 

So you do the query here. You define what is the query that you're calling. So again if we go back here this is the type of query we can do and it will return a friend and if we go back to our code this is pretty much what we've defined here. So we can do a friend query and it will return a Friend and then these are the types of properties that you can call on graphQL. So you can call anything you want and it will return only that information and not anything else. 

So if I'm not calling the last name it's not going to return the last name. So if we were to run this particular query it gives me what we've actually coded in the resolver. So it gives me the id that I've coded, first name, last name. So if I just wanted to have the gender I could actually just call the gender like so, and I will get the male. And so on so forth. So this is how you make queries, simple queries in graphQL. One of the things that is really cool about graphiQL is that you can get an history of all the queries and mutations that we're going to do down the road, that you've done. 

So if you want to repeat the same thing again you can simply click on the queries that you've done. So if I ran hello again it's not going to work. If I ran the first query that I've done for the new code then this is going to return what I've done in the past. And so on and so forth. So as you start adding mutations you're going to see all the history of your queries and mutations here and you can actually star them as well. So you can always go back and do this a lot faster. There's also another function that you can use here which is called prettify which will basically make your query a lot cleaner and still run successfully the same thing. 

So as you can see it's pretty straight forward to build your schema and then run queries only on what you need. So let's move on. 

## Initial Graphql Set-up
To be able to make graph QL queries you need to define a schema which defines the query type and resolver for each api input. So type definition provides what type of data we expect and the resolver gets the data for us. So we'll get started by defining our friend's type for application and then resolve it with fake data for now. Alright! So the first thing, let's go in the schema.js. So if you don't have it open just click on schema.js here and we'll change a little bit of our schema. 

So the first thing I want to do is keep the type query but change the hello to friend and then we expect to return a Friend, but right now if we do that it's not going to work because we haven't defined what a friend type is yet. So let's go ahead and do that! So, the type Friend and we use the same approach as our query. Takes an id We also need to have our first name which we expect the String, we'll do the last name again for String and gender will expect a String for now. 

We'll change that in a couple of videos. Language will expect also String. So right now we only have Strings. We may have different types as we go through all those different types. But you have string. You have number. You have bullion. And you have many others that we'll explore as we go through the course. And the last one is an email which is also a String, okay? So that is pretty much it for our schema so make sure you save it. 

Then let's go in the index and update the index as well. Because right now we're resolving hello so if we were to do the query with friend and returning a Friend then this wouldn't work. It would actually throw us an error. The type doesn't match the resolver. So we need to change this. So right now what we'll do is change hello to friend, like so. And let's completely remove this and we'll create an object like so and in this object we'll return what we'll just do here so we'll basically resolve each field that we created in our schema. 

So if you take a look we have id, first name, last name, gender, language, email so we need to have all these here. So for an id let's just do a fictive number. This is all fake data but eventually we'll have real data as we get our persistence set up. So the first name will have Manny Last name, you want to make sure that your syntax matches exactly what the types are. So if you do something like this, first name and then your type has a first name with a capital N here that wouldn't work. 

So you want to make sure that your types matches exactly what you're resolving in this function. So the last name is Henri. Then gender, let's do male. Language, english and email me@me.com And don't try to email me at this email. 

It won't work. Okay. So we don't change anything else so the schema is basically the same. The rootValue stays the same. Everything else stays the same so let's save that. And let's open up our terminal to make sure our server is running. So our changes already refreshed the server. Let's go inside of graphiQL here and test this. So right now let's refresh graphiQL. 

I'm just going to manually re-enter the local host, 8080 graphQL. M'kay. So if I'm running this, I'm going to have an error. So this is no longer existing in the server. So if you take a look at the documentation explorer basically gives you what type of queries you can do. So if we take a look at the queries that we can do So you can click here and it tells you that we can do a query called friend and it will return a Friend. So these are things that we can call when we do a query under friend. 

So let's go ahead and change that, so as I've said in the past when you start entering things in graphiQL, it's going to recommend what you can do here. So let's say for example I do a query and then my query is friend. Then I can start typing what kind of data I want to return from the friend so I can basically get the id. I can get the first name. And the last name. So this is how you do a query in graphiQL or graphQL. 

So you do the query here. You define what is the query that you're calling. So again if we go back here this is the type of query we can do and it will return a friend and if we go back to our code this is pretty much what we've defined here. So we can do a friend query and it will return a Friend and then these are the types of properties that you can call on graphQL. So you can call anything you want and it will return only that information and not anything else. 

So if I'm not calling the last name it's not going to return the last name. So if we were to run this particular query it gives me what we've actually coded in the resolver. So it gives me the id that I've coded, first name, last name. So if I just wanted to have the gender I could actually just call the gender like so, and I will get the male. And so on so forth. So this is how you make queries, simple queries in graphQL. One of the things that is really cool about graphiQL is that you can get an history of all the queries and mutations that we're going to do down the road, that you've done. 

So if you want to repeat the same thing again you can simply click on the queries that you've done. So if I ran hello again it's not going to work. If I ran the first query that I've done for the new code then this is going to return what I've done in the past. And so on and so forth. So as you start adding mutations you're going to see all the history of your queries and mutations here and you can actually star them as well. So you can always go back and do this a lot faster. There's also another function that you can use here which is called prettify which will basically make your query a lot cleaner and still run successfully the same thing. 

So as you can see it's pretty straight forward to build your schema and then run queries only on what you need. So let's move on. 

## Basic Graphql Schema
To be able to make graph QL queries you need to define a schema which defines the query type and resolver for each api input. So type definition provides what type of data we expect and the resolver gets the data for us. So we'll get started by defining our friend's type for application and then resolve it with fake data for now. Alright! So the first thing, let's go in the schema.js. So if you don't have it open just click on schema.js here and we'll change a little bit of our schema.

So the first thing I want to do is keep the type query but change the hello to friend and then we expect to return a Friend, but right now if we do that it's not going to work because we haven't defined what a friend type is yet. So let's go ahead and do that! So, the type Friend and we use the same approach as our query. Takes an id We also need to have our first name which we expect the String, we'll do the last name again for String and gender will expect a String for now.

We'll change that in a couple of videos. Language will expect also String. So right now we only have Strings. We may have different types as we go through all those different types. But you have string. You have number. You have bullion. And you have many others that we'll explore as we go through the course. And the last one is an email which is also a String, okay? So that is pretty much it for our schema so make sure you save it.

Then let's go in the index and update the index as well. Because right now we're resolving hello so if we were to do the query with friend and returning a Friend then this wouldn't work. It would actually throw us an error. The type doesn't match the resolver. So we need to change this. So right now what we'll do is change hello to friend, like so. And let's completely remove this and we'll create an object like so and in this object we'll return what we'll just do here so we'll basically resolve each field that we created in our schema.

So if you take a look we have id, first name, last name, gender, language, email so we need to have all these here. So for an id let's just do a fictive number. This is all fake data but eventually we'll have real data as we get our persistence set up. So the first name will have Manny Last name, you want to make sure that your syntax matches exactly what the types are. So if you do something like this, first name and then your type has a first name with a capital N here that wouldn't work.

So you want to make sure that your types matches exactly what you're resolving in this function. So the last name is Henri. Then gender, let's do male. Language, english and email me@me.com And don't try to email me at this email.

It won't work. Okay. So we don't change anything else so the schema is basically the same. The rootValue stays the same. Everything else stays the same so let's save that. And let's open up our terminal to make sure our server is running. So our changes already refreshed the server. Let's go inside of graphiQL here and test this. So right now let's refresh graphiQL.

I'm just going to manually re-enter the local host, 8080 graphQL. M'kay. So if I'm running this, I'm going to have an error. So this is no longer existing in the server. So if you take a look at the documentation explorer basically gives you what type of queries you can do. So if we take a look at the queries that we can do So you can click here and it tells you that we can do a query called friend and it will return a Friend. So these are things that we can call when we do a query under friend.

So let's go ahead and change that, so as I've said in the past when you start entering things in graphiQL, it's going to recommend what you can do here. So let's say for example I do a query and then my query is friend. Then I can start typing what kind of data I want to return from the friend so I can basically get the id. I can get the first name. And the last name. So this is how you do a query in graphiQL or graphQL.

So you do the query here. You define what is the query that you're calling. So again if we go back here this is the type of query we can do and it will return a friend and if we go back to our code this is pretty much what we've defined here. So we can do a friend query and it will return a Friend and then these are the types of properties that you can call on graphQL. So you can call anything you want and it will return only that information and not anything else.

So if I'm not calling the last name it's not going to return the last name. So if we were to run this particular query it gives me what we've actually coded in the resolver. So it gives me the id that I've coded, first name, last name. So if I just wanted to have the gender I could actually just call the gender like so, and I will get the male. And so on so forth. So this is how you make queries, simple queries in graphQL. One of the things that is really cool about graphiQL is that you can get an history of all the queries and mutations that we're going to do down the road, that you've done.

So if you want to repeat the same thing again you can simply click on the queries that you've done. So if I ran hello again it's not going to work. If I ran the first query that I've done for the new code then this is going to return what I've done in the past. And so on and so forth. So as you start adding mutations you're going to see all the history of your queries and mutations here and you can actually star them as well. So you can always go back and do this a lot faster. There's also another function that you can use here which is called prettify which will basically make your query a lot cleaner and still run successfully the same thing.

So as you can see it's pretty straight forward to build your schema and then run queries only on what you need. So let's move on. 
<br/>

# 2 Types and Schemas

## Object Types and Fields
 If you're familiar with type checking with libraries like TypeScript or Flow, exploring types in GraphQL will be familiar to you. Everything in GraphQL is defined by types as we've done already in our schema. So basically when you are defining a type, you are defining the shape of how this data will be and what type of data it expects. For example, in your current type friend, we are expecting the data to contain an ID, first name, last name, setup. So this is your object type for the friend.

 Like any JavaScript object, inside of it we have the fields and then declare what type of data we expect for this field. For example, first name is a field and we expect a string. The field could be a string an array of another type, et cetera. We'll go through every option possible as we go through this course. So let's say for example, we want to have multiple emails for this particular field here. So what we would do is create a new type called email and then make sure that this one is an array of email.

 And if you put an exclamation point, that means that this is mandatory. So that means there needs to be something in that particular field in here. So if we don't have any exclamation point, that means that this particular field can be left empty when we first create it. So let's create the type email like so. And basically what we're expecting is an email in a string. Let's make sure that we don't have the same type. So this would be emails and not email.

 Like so. And then all you had to do at this point is change the actual resolver here. So we can accept multiple emails. Otherwise it's not going to work. So let's go ahead and change that very quickly by adding an S here. And then this takes an array. So let's change this here as an array. And then for each item we take an object here. And then let's add another one like so. So let's just do that on the second line here like so.

 And then add the second one just below. And we want to make sure that we enter the type for that particular email. So if you go back to the schema, we take an array of an object email here. So each object needs to contain the actual property here, the field, and then the actual value. So we need to make sure that we have that here. And then we have the actual values. So we need to repeat that for the second one as well. And then another@me.com.

 So there you have it. So let's save that. Let's go back into GraphQL. And then this time if you take a look at the documentation again, friend. Let's refresh before we do that. Because right now it's showing the old way. So if you take a look at query then friend, this is expecting a string of emails. So let's say for example, we are calling the emails. Then when we return it, we'll get the array of emails like so.

 So the first email, the second email. So as we explore GraphQL you'll learn about many other types and we'll go through each of them. So let's move on. 

## Query and Mutation Types

## The Resolver and Its' Role
So you have heard me talking about resolvers in C2 so far. Basically, resolvers are the functions that respond to queries and mutations. They are the function that gives us the result of the query. And because the standard approach is to leave the schema only for type definition, we create those functions separate from the schema. So you can get either have them in a separate file and then import them into your main server file, or have them into your main entry server file, in this case our index.js. So we used the second method thus far, so let's extract the resolvers into their own file and go through the ones we have so far. 

Okay, so first go into the index.js, and basically copy from line 43 up up to the class, so line 11. So 11 through 43, cut that, and then let's create a new file. So use whatever function you use to create a new file. So in this case I'm using this little icon here. New file, and I'll call this file resolvers.js, and then in this new file I will paste the code that I extracted like so. 

So your class should be the same, the database should be the same, and then instead of root I will call this resolvers. And then instead of manually returning our friend here let's do something else. Let's actually create a function or resolver that will allow us to get a friend once we have created something in our database. So let's remove that and call this one getFriend, and this will be a function, which will take an ID. 

Now let's clean that up. I'd to have this cleaner, and then this function will basically return a new Friend with the ID from the friendDatabase and the position as the ID like so. Let's put a comma here and we have our resolvers. So the last thing you want to make sure because, right now if I leave it like that, I'm not going to be able to access anything from this file here. 

So let's make sure that we actually export our resolvers like so. Okay, so we'll save that. Then in our index let's make sure that we change our code here to accept our resolvers that are external. So let's make sure that first we import resolvers from resolvers, and then let's make sure that we actually are passing the resolvers to a constant root like so. So now everything should be working nicely here, and then the last thing that we need to do is actually define the getFriend in our queries. 

Let's go ahead and define this here. So in our queries here as opposed to do the friend and return Friend, let's do the getFriend and then we need to pass an ID like so, and then it will return a Friend like so. Okay, so we don't need anything else. We can save that. Let's make sure that there's no errors on our server. So let's bring the terminal. Everything is running nicely here. 

Let's make sure we refresh our page here, and now we should have the query type here, getFriend, and if we have your mutations up, because our server has been restarted, we need to create the actual new friend first before we actually get one, otherwise we don't anything in our database right now, and this is where the history is going to be very useful. So if we didn't have anything here, I could literally go in, okay, I create a new friend here. So let's call in and use the same thing here. 

So let's go ahead and use that, so run it. So I got an ID for this new friend, so let's go ahead and copy that particular ID here. So copy that, and then let's use the query that we just created. So create query, then getFriend, and getFriend takes an ID like so. So you want to insert what you just copied, and then exactly what do you want to get from that particular friend that we created. So let's go ahead and get the firstName, and I believe we had a lastName on that query. 

So let's go ahead and call this, and there you go. So you have your getFriend and you return the firstName and the lastName. So now that we've got a solid base for our GraphQL server, let's continue exploring other types GraphQL uses. 

## Scalar Types
Scalar types are basic types that comes GraphQL and can be used without having to create type beforehand. With GraphQL, we have access to these basic scalar types. We have int, for integers, your regular number. We have float, which is a float number, which basically includes a decimal point. So, example, 4.56. We have string, for any list of characters, like we've used so far. We have an ID, which is a unique identifier for each entry in GraphQL, and we have boolean, which has a value of true or false. 

For each field we enter into our type, like our friend type, we need to define what scalar type it takes. Let's add a new field with a different scalar type to our schema. Let's go ahead and add to Friend. Whenever we add new things or new fields inside of a specific type and we have also an input type that actually influences that type, we need to make sure that we have the same fields. For example, if we add age here, and for age we take an integer, then we want to make sure that we also have it in the FriendInput, like so. 

Again, the other thing that we absolutely need to make sure when we add new fields into our types, is to go into the resolvers and make sure that we also update the resolvers. As you remember, we have a class of Friend with a constructor, that initializes these types here. So, we want to make sure that we add also the age. Let's go ahead and do that here, age, and let's add it here as well. So, this age equal age, like so, and then everything else should be good to go. 

Let's go ahead and create a new type with age, just to test it. Let's go ahead and use some of the mutations we've used in the past, and add age. Age takes a number, so let's go, and I'm going to make myself a little bit younger today. Before we actually do that, let's refresh our server, just to make sure we have the latest and the greatest. Let's make sure it also shows here, so mutation, friend. We have age here, so we're good. 

And the query as well, so let's go in the query. The friend is returning also age. Okay, so we have age here, and let's return it as well here. There you go. We added a new integer inside of our type. Basically when you create your types you can essentially use any of these for your fields. Let's move on.

## Enumeration Types
Enumeration type, or commonly called enums, is a special scale type that allows you to define a specific set of data the field takes, and restrict the input to what you list in the enum type. Let me demonstrate so we can make better sense of this type. So if you don't have schema.js open, click on schema.js, and then just below the type on line 12, hit return and then we'll set a new enum type. So it's basically the way it's spelled, enum, and then we'll set an enum type for gender. So we want to restrict the choices that gender is allowing to enter. 

So what we are going to do is, MALE, and by the way, all the fields inside of an enum should be uppercase. So MALE, FEMALE, and then OTHER. And then make sure that you have that change in here, in the gender, so now it's taking a gender type, and also in the input, because if you don't have it in the input, you'll be able to enter a string in the input and then when it returns it, it's not going to be able to return the right values. 

So let's make sure that we have it here as well, like so. And then last, on every change in the schema, always check your resolvers. We don't need to change anything for this one, because gender is already there. But, for any change in your schema, always check your resolvers, just to make sure that you don't have to make any changes for it. Example, if we added a new field, then we would have to change it here, but in this case, it's not needed. All right, so let's go and test this in the browser. And let's make sure we refresh our server, like so. 

And if you want to make sure that everything is fine here, let's go and check the queries. Queries takes a friend, and then the friend has gender, which has these values that we can input. And then the same thing on the mutation, takes a friend, and then the gender is here. All right, so let's change the gender here. So let's make sure we don't have a second gender in the same line. Okay, so we're clear. And let's enter gender. 

So if I was to enter gender, now I have the choices. So if I enter M, I have MALE/FEMALE. If I enter O, I have OTHER. In this case, I want to test if I entered the wrong value. So let's go and enter a string instead, like it was before, and enter, I'm a gender: alien, and run this query, this mutation. And then it tells me, "Wait a minute. "This input actually takes an expected something specific, "so please redo this mutation." So let's go ahead and change that and make it to MALE, like so. 

Run the mutation, and now it's successful. And let's go ahead and use the ID here, so copy that, and let's go under History, so getFriend, and paste the specific ID we just created, and I want to get the gender, like so. And then run it, and there you go. I have the gender, and it's the MALE. So whenever you need to restrict a type of data the field takes, enums are a great way to do it. 

## List of Types Inside Another
In many cases you will need to have inside of a field, multiple values, for example, a list of episodes a character is featured in for a television show. This is where you can create a type and use the array characters to signify a list of items inside the field. In our case, we would like to implement a way to list contacts for a friend. Let's get to it. So again, open the schema, and inside of our type Friend here, let's create a new field called contacts, like so. And then this contacts takes a list of contacts, so you are making an array of a type Contact. 

So we need to create that type. So let's go ahead and create the type Contact, which will basically have a first name, which is a String, and then a last name, which is also a String. And let's make sure we also create an input, so we can enter these contacts. So we need to create a contact input. So just below the input here, let's create a new one, ContactInput, and again, same thing here. 

So let's copy from line 16 to 17, and let's paste these right there, very simple. And in the FriendInput as well, you need to enter that it takes contacts, and we are taking from the ContactInput, like so. So there's no other changes on the schema. Save that, and then in the resolvers, we need to add the new type in the constructor. So let's go ahead and do that. 

So after email here, create contacts, and then add it at the end here. So this.contacts equals contacts, like so, and save this. And then we can play with that new type that we created. So let's go ahead and refresh the server one more time. Let's take a look at the documentations, so the mutation will take FriendInput, and in the FriendInput, we have now the new field for contact and then the contact input takes firstName: String, lastName: String. 

So let's go ahead and then create a new mutation, and in here, let's add, just below the email, contacts. And what does contacts take? It takes an array of multiple objects. So we are passing our first name, so let's say my first contact is called Lolo, and last name, call yeah. Then let's add another one. FirstName:Lulu, and lastName: yo. 

Okay, so now I want to return as well the contacts that I have in my mutation. So let's go ahead and create that. And then I have my contacts here, firstName: Lolo, lastName: yeah, and so on and so forth. So I have an array of contacts inside of my new friend. So let's go ahead and also do the query, so copy the ID, and let's go and get the getFriend, and paste that. And then let's remove the firstName, lastName, just to show you that you can only get the data that you need from GraphQL, and not all the other stuff that you don't. 

And get the contacts, and then run that query, and now I got the contacts. I could even go one step further, because if I enter contacts, it's going to assume I want all the data. But what if I just wanted the have the last name? You could do that as well. So you can be as as specific and/or vague as possible with your queries, and get exactly what you need. So if I run this query, now I'm getting only the last name. So this is very, very useful when you have an application that needs very specific things from your data. 

So if you have multiple databases that are connected to GraphQL, and you only want to have specific things from one database and then specific things from the other database, you can literally pick and choose the type of data that you want. So as you can see, this is very useful to create sublists of items for your type. So let's move on. 

## Using Graphql Tools
In the GraphQL community there are multiple tools you can use to work with your schema to keep it clean and use GraphQL syntax first like we've done thus far, but for some of the future subjects we'll cover, using an approach similar to the syntax used with GraphQL tools will be beneficial for us, and therefore we'll continue with this tool and refactor our code a little bit. As a side note, you will in the community two approaches to write schemas, one that is exactly the same as we've been doing here in this schema, and another one that has a lot more code to it and is also more JavaScript friendly. 

So let's go and take a look at both. So this is the approach. So if you go to graphql.org/graphql-js/cnostructing-types and then scroll down to this first area. So this is how we've actually build our schema so far, but there's also a second approach where you'll see something like this where you are creating a new GraphQLObjectType, and then name User, and then define the fields, and so on and so forth. 

Both approaches are good, but because the first syntax here is a lot simpler and requires to use some tools, this is exactly what we'll use from this point forward. So both are valid, and it's basically a decision for the developer to make. So let's go ahead and install some tools that we'll need for our future videos. So go inside of VS Code, and open up your terminal. So you can go to view, integrated terminal, and then let's stop the server, so Control + C, and then then do npm install --save, and what we want to install is GraphQL tools, so -tools, and then we'll refactor a little bit of our code to accept the new tool and leverage some of the features that comes with it. 

So first let's update our schema. So what I want to do as opposed to create a const schema, let's call it typeDefs like so, and let's remove this, and make sure you remove the last parenthesis here like so, and do a semicolon. And what we'll do as opposed to import buildSchema, we'll import the resolvers from resolvers, and we'll also import from the GraphQL tools, makeExecutableSchema from graphql-tools. 

And let's make sure it has been installed, GraphQL tools. We're good to go, perfect. All right, so at the end here as opposed to export default schema, let's do a const schema equals makeExecutableSchema and use the typeDefs and the resolvers, and then export scheme, but with curly braces like so. 

Okay, and then in our resolvers we're going to change this particular resolver here. So let's go ahead, and everything else stays the same, and what we'll do is call a resolver map. This is something that has been introduced with the GraphQL tools, and it helps us to map our resolvers better. So instead of doing just a const, let's export the resolvers, and then create inside of our resolvers here, create a Query, and then the Query object will have query resolver like so. 

Nothing changing in terms of the resolvers itself, but it needs to mapped out better. So then put a comma on line 22, and then we'll create Mutation, which is an object, and then inside of it we'll cut from line 26 to line 30, and paste it inside here like so, and put a comma there, and then put a comma at the end here, and then, because you're already exporting your resolvers here, you don't need to export them again. And now the last thing you need to do is to properly import your schema here, and you're importing it with curly braces like so, and we don't need the resolvers anymore like so because we're going to do something different very, very soon. 

So let's remove that. We don't need the value here, so let's remove that, and by the way everything that we're doing now is to prepare our GraphQL server to accept persistence and work with Mongo and SQL. So this is why we're making some little changes here. So let's go ahead and remove the rootValue here. We don't need it anymore, and then the schema you can leave it as so or you can do it pretty much the ES6 way like so if you want. 

Both ways work. Okay, and then save this. Okay, so now that we have our project updated with the GraphQL tools, let's move on. 
<br/>

# 3 Setting Up Persistence

## Installing MongoDB
Right now our data is only saved in memory and when we stop, the server would lose any data persistence. So with our GraphQL server up and running and now with some knowledge about how it works, let's add data persistence with MongoDB. So let's go ahead and first go to mongodb.com and then scroll all the way down and click on installation here and then install MongoDB Community Edition and then select the operating system you're running on. 

So if you're running on Windows, click on this one. If you're running on Linux, click on this one. If you're having any issues with any other installations, follow the step-by-step for the operating system and you should be fine. So in our case, we'll use Homebrew to install the Community Edition and then we'll do a couple commands that are required in order to make MongoDB run. So let's go ahead and first install Homebrew. So I'm assuming you don't have Homebrew so that's exactly what we're going to do. 

So on brew.sh, so this is where you need to go, basically copy the line here and run it inside of a terminal. So let's go ahead and stop our server in Visual Code Studio and run this line here. Press Return and then the password for your computer. Okay, so now that we have Homebrew installed, what I'm going to do is a step that some of you may not need to do. So if you already have Homebrew installed, I would suggest you do a brew update. 

But for those that just installed it, you don't need to do that. And then what we'll do is brew install mongo. Once you have this installed, there's another step that you need to do and unfortunately we can't do it in this terminal because we are in this particular directory so we need to do that in the root directory and let's open a regular terminal on Mac. And if you're running on Windows, then again follow the procedures of the Windows install. And what I'm going to do is a command called make so mkdir -p and /data/db so what we're doing here is creating the directory for the database. 

And because we have no permissions denied and I did that on purpose so that you guys know that some of you may have the permissions. For those that don't, do a sudo first so mkdir -p /data/db and then the password. There you go. So once this is done, what you need to do is again set the permissions because right now we created the folder directory, but we don't have permissions to read and write to it so we need to change those. 

So the way you do this is by doing sudo chmod so C-H-M-O-D 777 and then the actual directory you want to set the permissions to. There you go. So now this is done. Then we can start Mongo and you do that by doing mongod. And if everything is running like this, that means that it is installed and running properly. Okay, so the next thing we need to do, let's get back into our project here and now let's install Mongoose. 

So a quick introduction, so Mongoose basically is a library to help us with modeling our database and bring several built-in tools to help us with validation, business logic hooks, et cetera. So if you'd like to get more details around Mongoose, feel free to take a look at the documentation in depth. We'll cover some of the basics as we build our APIs so let's go ahead and install Mongoose. So let's clear that up so clear and let's make sure we are in the right directory so we are here so we're good. And what I want to do is install by doing npm install --save and I want to install Mongoose like so. 

And we have it installed. Let's check to make sure. We got Mongoose here so we're good to go. Okay, so now got Mongoose and we got MongoDB ready to go so let's move on. 

## Finalize MongoDB Set-up
Now that we have the necessary items to connect to Mongo database, let's finalize our server to properly connect to it. So the first thing I want you to do, is create inside of ESSENTIALS here, so the root directory, a new folder. So you can do this by creating a new folder here like so. Or, right-click, or use whatever methods that your code editor allows you to do. So, I'm going to do this. And then, I'm going to call this particular folder data. And what I'm going to do is move the resolvers inside of data. Yes. 

And then, move schema as well inside of data. Like so. And please, keep in mind that we need to properly import here so we need to add also data here. So now, schema is not in the root directory so we definitely need to get inside of that folder so let's update that particular import here in index.js. So, data and schema, like so. Okay. And then, let's create a new file inside of data. And this file will be called dbConnectors, or you can call it whatever you want as long as you know what to import when we use it. 

So, right-click on data, New File, and I'm going to call this one dbConnectors.js. And, this particular file is where we're going to connect to our databases. So, the first one that we need to connect to is Mongo. So we'll do this with mongoose from mongoose, like so. And let's use mongoose, and let's comment this area here, so Mongo connection, so we can refer to it later on if there's any issues. 

And, we'll use mongoose and use a Promise, global Promise, so basically what we're doing here is using promises so when we connect to Mongo we are using a promise to do so. We're not waiting after the connection to go on with our lives. Mongoose and we are connecting, and we are connecting to mongoDB. And we're going to on the localhost like so. 

And we're going to call the new database friends. And once we're connected, please put this option, useMongoClient, because if you're not using this particular option, it's not going to work. And I did mention this in one of my previous videos, why that is. Semi colon. And then we're going to create the schema for Mongo. So we're going to call this one friendSchema equals new mongoose schema, and this is a function, which creates an object with, and now we need to add all the things that we used in our schema. 

So, we need to create a firstName, which is a type string. And then let's copy this, because we're going to repeat more of the same. So this one is a lastName. And then we're going to do gender which is again a string. Paste again. Then on this one, we're going to do the language. We also add age here, so let's make sure that we have that one too. And this one is a number. 

Let's put a comma there. Then we have email, which is a string. And finally we have contacts. Which is an array. Okay. So once we have our schema generated what we need to do is to make sure that we create a value to our variable with that model inside of it. And, we'll call this friends, and not firends, and we'll pass the friendSchema to it. 

Alright, so basically what we've done here is we connect to Mongo, then we create a schema here, with all the stuff that we had in our schema here as well. So, firstName, lastName, gender, age, language, email, contacts, like so. And the age, just to make sure, is after gender, yes. So I like to have things structured in same way from the schema here to the other schema. Yes, the email was after. 

Okay, cool. So then what I want to do is create a new model here. Passing the schema and this is the name of the model. And save this file. Okay. Last thing we need to do is change our resolvers and we need to change quite a bit. Because we don't need to create our in memory database anymore, we can all get rid of this. So basically everything that we had from the database, and the constructor, and the class. We don't need any of that anymore. Now, we need to import mongoose again from mongoose, like so. 

And what we're going to do, and let's make sure we actually exported it. So on our dbConnectors, we need to export at the end our friends, so let's export that here. So export our Friends like so. Save that. And now, we're going to import it here in the resolvers. So, import Friends, like so, from dbConnectors. Once we have that imported, then we can change that here a little bit. 

So, what is going to change basically is how we mutate. So, we'll work on the query a little bit later on, but for now, what we'll do is change our mutation because when we create new things inside of our database, this is going to change. This was the old way, when we were creating it in memory. And now, we're going to create it inside of our database Mongo. Alright, so the first thing I want to change here is in the arguments here, I want you to add root and then everything else is the same here. 

And then inside of this particular, we are going to change all this here, so let's remove all that. And then we'll create a newFriend object, which is a new Friends. So now we're leveraging, this is no longer a class, we're actually leveraging the friends that we've imported from the connectors. And, this will allow us to create a newFriend inside of our database. So what we need to do now, is do firstName, will be the input passed from here, dot firstName. 

And then we copy and paste all this until we get all the stuff that we need to get. So, the second one is lastName. So Option, Click lastName. Then we need to get the gender, so Option, Click here, gender. Then the same thing again for language. Paste again for age, is the next one. And let's take a look at what we have here. 

So, we have gender, then age, language, and I like to have things structured. You don't necessarily have to. But, I like to have them structured in the same order. So, if you debug after that, you don't have to look for things and they're all messed up because they're not in the same order. So I got firstName, lastName, gender, age, yep. And then language, and then email, contacts. So let's continue. The next one is email. Option Click, email. 

And then the last one is contacts. So now that we have our object, our newFriend object created with the inputs that we got in our function, in our resolver. What we need to do after that is create inside of the database the new items. So, newFriend, and we'll assign it an ID. Equals newFriend underscore id, so this is something that is assigned directly from the database. And then, what we'll do is return a new Promise because we'll send basically our object that's just been created to the Mongo database and then we need to wait for a response before we can actually resolve it inside of our GraphQL server. 

So, let's resolve, let's pass the argument resolve. And pass an object, which will come from the promises. So then, we are saving it to the mongoDB. And we're passing an error as an argument so if there's any errors while we save it, we want to know. If there's an error, then reject the error, else resolve our Promise with our newFriend. So basically what we'll get at that point is the result, which will be return inside of our GraphQL server. 

Okay. So, that's pretty much it. Alright, just before we leave, make sure you save. Okay, so now we have mongo setup, now let's move on. 

## Data Persistence in SQL
Now that we have Mongo set up, let's add a second database and install SQLite. So, the first thing we want to do is install the few things inside of your package.json. So, good inside of package.json. Okay, so let's install the few things, so npm install --save and we want to install casual, and this is how we're going to get some fake data. And then we want to install lodash and sequelize, and finally, sqlite3, like so. 

Okay. And now what we want to do is get inside of our dbConnectors 'cause now we're going to create a connection to SQLite. And we're going to do this by first importing, import Sequelize, like so, from 'sequelize'. Then we're going to import lodash, and when you import lodash, this is the common practice where you do an underscore like that. 

And we're going to import casual from 'casual'. Okay, so now that we have these installed, let's scroll after our Mongo stuff right here and let's create a section that I will comment SQL. So, if you see any problems with SQL, you know that you need to go into that code here. And the export can stay after because we're going to export the new database that we'll create as well. 

So what we want to create first is a variable called sequelize and use a new Sequelize, and that's why I did a capital S on this one, so we don't mix up the two. And we're going to create a new database, a new SQL database. And the next two values are basically the login and password, so this is not a course on SQL databases, so I'm not going to focus on any of that for now but if you want more information on it, take a course on Sequelize and SQLite and you'll get more details around that. 

And then what we're going to do is use the dialect of SQLite. So basically, we're mentioning which dialect we're using. And then where the storage is going to be, so where our database is going to be. The reason why we're using Sequelize and SQLite is because we're able to create a database or persistence inside of our project without having an external database that is huge and big and create a server like we've done for Mongo. 

So, this will create a file inside of our Essentials here and this is where our persistence will be pretty much like Redis. Okay, so where we want it is here and we'll call this one aliens.sqlite. And once we start our server, you're going to see that file appear in our Essentials root directory here. Okay, so now that we have created a new database, let's create our schema. So, we're going to create a new schema called Aliens and we're going to leverage the sequelize database that we just created and define it, so we're defining the aliens schema. 

And what we're going to do is have a firstName for Alien. And again, we need to define a type. And this one is Sequelize, with a capital S, make sure you use capital S on this one, dot STRING. Then we're going to define also a lastName, so let's copy this one here. Copy line 45, paste it here. And then do lastName, and this is all the same. And last but not least, we'll define which planet this alien is coming from. 

And again, this will be a string. So, type: Sequelize.STRING, like so. Okay, so our schema is created. Now the next thing, we need to sync what we just created and we'll force it. So these are specific commands related to Sequelize, and we'll force it too, so it'll be forced to sync once we start the server. And then once you have been synced, we'll actually create the fake data. 

So, for this one, we're not going to use mutations. We'll use mutations with Mongo, but for this one, we'll simply create fake data that we'll be able to query with GraphQL. Let's go ahead and do that. And this is where our casual and lodash will become useful. So we're using underscore, so lodash, to basically create 10 times casual data that we'll name here. So, it will go through that command below 10 times. 

It will create in our database called Aliens 10 different people with a firstName and lastName and et cetera, et cetera. So we'll use casual to create a firstName, like so. And casual has _first_name to create a first name, and let's do the same for the last name. And let's create last name for this, and this is coming from casual. 

And for the planet, we'll just simply create words. So basically, casual has a way to create specific words. I know these planets, they're going to sound weird for some of 'em, but the idea is to create some fake data here and actually, we're kind of using a science fiction approach to this. So, any word, we'll do a planet name and it will work. Okay, semicolon, semicolon. And then finally, you are exporting Friends and Aliens. All right, so let me quickly recap what's happening here. 

So, we are creating a new database here. We're using the sqlite dialect and the storage is going to be in the main directory here. Then we are defining what the schema is going to look like, so we're going to have a firstName, lastName, planet, and these are all types of string. And then finally, we are going to force the creation of a new data whenever the server starts. So whenever we start the server, you're going to see 10 items being created on your console log. 

And then they will be created with casual and add a firstName, lastName, and then a word as a planet. There you go. And the last thing that we need to do is to create a type inside of our schema, so our GraphQL schema needs to have a type for alien. Otherwise, it's not going to accept anything inside of GraphQL when we query, when we create the new items, so let's go ahead and create that as well. So, let's go below our Friend, so we've got something in order, and create a type called Alien, and this will take an id: ID. 

And then the firstName, lastName, so let's copy these from the Friend here back down here. And then finally, we have a planet, which takes a String, like so. Okay, so now we have a portion of our SQL database set up. We'll leave updating our resolvers as we go through GraphQL's query features, so let's move on. 

<br/>

# 4 Mutations

## Add New Items with Mutations
Before we begin, please run NPS start. Now that we have all of our database properly connected and we have a simple mutation added to our server let's test it and use a different tool to test as well. Okay, so let's go and take a look at our first mutation. So if you remember in a previous video we actually added a mutation already. So we add this mutation here. So create a new friend and then in our resolvers we have that mutation here where we're creating a new friend and then we're creating an object which we then create a new item in our database and this is in our Mongo database so this is not the SQL. 

So the SQL is being created when we first start so we saw that in the last video here and then we'll use a query to get the item from this particular database, but for now let's focus on Mongo. Because we already have a mutation created what I want to do on this video is to add a tool that will allow you to cross check that there are new items in your database, in your Mongo database. So let's go ahead and do that. So switch to your browser and now make sure that your Mongo database is actually on, so you should see these little lines here, so receive client connection accepted, things like that. 

So if this is not running make sure to run your Mongo database. So let me just simulate the fact that it's off. So now it's off and then just do Mongod, so M-O-N-G-O-D, start your Mongo database, now it's working, we're good to go. Okay, so the tool that I want you to install is called Robo 3T and it's on RoboMongo.org and it's a free tool that you can install on Mac, Windows, and Linux. 

So once you are on this website click on download Robo 3T and then click on download and then it's going to give you three options, so Windows, Mac, or Linux. So download the proper version, install it, so I'm going to install this one, so download, and just open that DMG file and as you can see I already have this installed on my system so there's probably the reason why I'm not going to do it again so to install it on a Mac, you just simply drag and drop in the application and you have it completely installed. 

So I have it already so go ahead and do that on your end and once you have it installed go ahead and run it. So the very first time you actually open Robo 3T, you won't have this here, so the way you create this is basically by creating here, so clicking on create, and then you can call this anything you want and just accept all the defaults. So basically this is how you're going to connect to the local database, so if you had your Mongo database remotely on a domain then this is where you would enter the remote address and most likely there would be documentations, for example, if you're doing cloud Mongo database then you would have all the documentation to properly connect to it externally, but in this particular case we are using local host one and the port is the same so all you have to do at this point is save it. 

I'm not going to do that because I already have one and I called it local so the name doesn't have any difference and once you have that then you can click on connect and then you should see a local database running. The very first time that you are running your database you won't see friends because we haven't created the friends database with the new data, but I have done it in the past so that's why I'm saying this and then use the browser and then let's create our new mutation. 

So let's refresh our browser again and then let's use the last mutation that we created. So remember your previous video, we used this specific mutation here. So let's go ahead and use that. So right now we have create friend with an input of first name, last name. If you don't have that, let's manually do it again just to make sure that you are following along if you haven't done this in the past. So let's go ahead and do a mutation. So, again, you can always use the documentation explorer to help you when you're doing your queries and mutations. 

So in this case we can use create friend and create friend takes an input and that input is an object of friend input, like so. So let's go ahead and do that and then it absolutely needs a first name, so if you don't enter a first name GraphiQL is going to give you an error. So the idea is created by the actual resolver, so we don't need to enter an ID, but we definitely need to enter a first name. So let's go ahead and create a new one, so call Tracey, then do last name, SmoochyPants, and then gender, let's say this guy is male, age, I have no idea so I'm just going to be nice, and then language, let's do German. 

Okay, so once you have your create friend object in there then you can ask the query to give you a few items in return. Once the new item has been created, so ID, let's go for the first name, let's go for the last name, and leave it at that, and let's create our new item. So, we got the confirmation here that we have created a new item, but we want to make sure that it is in the Mongo database. So this is where Robo 3T comes into play. 

So, let's go ahead and switch to Robo 3T, like so, and then just tap on friends which is the new database. So now you should see this database if you've done this command and you have a return ID plus first name and last name. You should be good to go and you should see friends now. If you don't, maybe because it hasn't been refreshed. So the way to do this, you basically refresh like so, so you right-click on the local database, refresh, and then you should see this. 

So click on friends, collections, and then you have a collection called friends and I have two items. So I created this item in the past, so this is why I see this, but this is the second item or the item that we just created. So if you see what you just created with the ID, the first name, last name, and so on, so forth, that means that everything is working nicely and you don't have to worry about any of the code that you've just written, it's working. Okay, so as you can see, it's fairly easy to add a mutation to our server, so let's continue working on our code. 

## Update Items with Mutations
In this scenario where you need to update items in the database with GraphQL, we also need to set up the proper mutation to do so. Let's get to it. So, the first thing we need to do is open schema.js. So, if you don't have it open, go ahead and click on schema, like so. And then, exactly here, in the type Mutation, we need to create a new Mutation, and this one we'll call updateFriend. And the input is going to be exactly the same thing, so input FriendInput, and then, we return a Friend, as simple as that. 

So then, what we need to do is get into our resolvers, so make sure you save that before you switch to resolvers. And switch the resolver, and then, just below the createFriend, so let's make sure we are adding something here. So on line 31, press Enter, and then we're going to create the resolver for Mongo to update a specific Friend. So, as you may have guessed, a specific Friend takes an input, like we've done for adding a new Friend, so we start with a root, and then we run a function. 

So, inside of that function, we are going to return, basically updating this Friend. So we'll use Promise because, when we are making the call to Mongo, we are not going to return a response until we get a response back from Mongo. So this is why we're using Promise. And we're using again resolve, and we're using object. And then, we're going to, basically, use the friends database, so we are using Friends. So, as you remember previously, we had imported Friends, which we've used to create a new Friend here. 

So we're going to use the friends database to update. So the function the comes with mongoose to update a specific item is called findOneAndUpdate. And it's a function, which takes a few parameters, so we need an id. So we need to identify the id that we're actually changing, and then we're going to pass the input as the things that we need to change inside of particular id. 

So this particular function, new true, means that if we don't have an item in the database that matches to that, then create a new one, and then we'll use error and friend as the parameter so we can do something with the Promise, so like we've done in the past, and this is basically going to be exactly what we've done here. So, if error reject error else resolve the Friend. So, it's not going to be the newFriend but the Friend. So let's copy that first, and then change it to Friend because that's the value we just passed in here, and not newFriend, like we've passed above. 

So, we have our resolver that will speak to Mongo, update the particular item in our Mongo database and then resolve inside of our GraphQL. So, let's go ahead and save that, let's open up our server, so let's go to View, Integrated Terminal. There's no errors here, we're good to go, and let's go to our browser and refresh our browser as well. 

Now, if we take a look at the mutations in our documentation, we should have now update Friend. So, let's go ahead and go to Robo 3T so we get at least an id of a friend that we want to change. So let's get this guy here. Okay, so we'll update this guy here. So, a little tip for Robo 3T. If you want to copy things in this view, you can't. If you want to copy things, you need to change the view. So, the view I usually go to to copy and paste stuff is the last one here, so the document mode, and then, what I'm going to do is scroll and then just copy this particular id here, like so, and then change my mutation entirely. 

Mutation, updateFriend, then this function takes an input, and my input is the id that I want to change is this one. And what I want to change on this guy, so let's take a look, what do we have for a name? We have Tracey, let's change it to Manny. So firstName Manny, and then age 34. That's not my real age, but I'm just saying that for fun, and then again, let's return something out of that. 

So let's return the first name, the age, and so. So, let's go ahead and run it. We run it, firstName has been updated, the age has been updated, but we got that response on GraphQL. Let's check that for sure on Robo 3T. So let's go back here. So, Robo 3T doesn't automatically update the values here, so you need to refresh yourself. So again, right-click on Local, Refresh, click on friends, click on Collections, click on friends again, and then it's the second one here, and you can see that the firstName has been changed to Manny and the age to 34. 

So there you have it. Now you'll be able to update any items with GraphQL. 

## Delete Items with Mutations
The final mutation we need for our GraphQL severs is to be able to delete data. So let's add this mutation. So, again, like we've done in the past, we need to first add the mutation in our type mutations, so let's go ahead and add a new one, and we'll call deleteFriend, and we'll take an ID, and it needs absolutely an ID, so that's why I've put the exclamation point here. And then we'll return a string this time, because once we delete a friend, well, it's no longer a part of the database so we shouldn't be returning the friend itself, because it's no longer there, so if we did that, it would give you a null answer. 

So let's return a message instead, that yes, something has been deleted in our database. So, once we're done with that, save, and then we go into the resolvers. And in the resolver, we'll create a brand new function, just below the updateFriend. So, on line 39, get a comma in there, and then return, and then deleteFriend, which, again, takes root, and the input this time is the ID. And this time, we'll return, again, a promise, 'cause we are calling onto a different server, so we want to make sure that before we actually resolve anything inside of our own GraphQL server, we get a response back from Mongo. 

So, we'll use resolve and object, like before, and if you want to copy and paste this particular area to save some time, most of it will be very similar. And then, inside here, we're using friends, and then using a simple function called, well, guess what, remove. And this function will take the ID that we need, so _id, because Mongo works with underscore, and we'll pass the ID that is in our input here. So, we'll pass in this particular argument here, in here, to select which one we need to remove. 

And then we'll do the err, and we don't even need the friend, so we could remove that particular line here. And then, do the function, and if err, reject err, else, and this is where it's different from resolving something, because we're not resolving friend, we are going to resolve a particular message. Successfully deleted friend, like so. And let's make sure we type that properly. 

And that's probably our delete function. There's nothing more that we need, so save that, and then go inside of GraphQL, and let's go ahead and grab someone we can delete. So, inside of your database here, refresh, click on friends, click on collections, then click on friends again, and then let's select this guy here. So, again, like I said in the past, the way to copy and paste inside of Robo T is by going into the document view, so click here, and let's go ahead and select this specific ID. 

I won't delete that one, so copy. Right click and copy. And then let's go in GraphQL and let's go ahead and make sure that we refresh the server. So now that we have the specific mutation that we just created, so click on mutation to make sure that deleteFriend is there, so it is. So let's go ahead and type out this mutation. So, create an object and deleteFriend, deleteFriend takes an ID to delete, and then let's insert the ID that we just copied, and that's all you need. 

So, once you run this particular command, successfully deleted friend. So, if we didn't answer a string or a message in here, we would get a null as a result if we wanted to return a friend, because that friend does not exist anymore in the Mongo database. So let's check that for sure. So, let's go in Robo T, and close that out, because right now, it hasn't been updated, so let's refresh that again. Click on friends, collections, friends, and boom, it's no longer there. 

So, now that we have the ability to add, update, and delete items into our database, let's move on to more advanced type of queries. 

<br/>

# 5 Queries - In-Depth

## Simple Query with Persistence
Now that we have some data to play with, it's time to explore the many options available with queries and start with a simple one leveraging the SQL database we created. Let's get to it. Let's go into our schema again, here, so if you don't have it open, click on schema.js here. Then instead of Mutation, let's go up to Queries here, then I want you to add one more query, so hit Return on there, and do getAliens, and what we'll return is an array of Alien, and by now we should have Alien also defined, so the type Alien is here, so we're good to go there. 

If you don't, please make sure that you refer back to that video or just look at the exercise files, but this particular type needs to be in here. Whenever you have any type or Queries or Mutations that are actually returning something, so our Friend are returning on the rate of a particular type, you need to make sure that you have that type defined somewhere in your schema. For example, we have the type Alien defined here, we have the type Friend defined here. 

When we are doing an input, we are leveraging here the ContactInput, so this needs to be defined in the input here, and so on, so forth. This is very important and you will get error messages if you don't have that. Let's make sure we Save. Then in our resolvers, we need to create a brand new resolver to get our aliens from the SQL database. Let's go ahead and do that. Right below the getFriend, just hit Return on line nine, and then just create a new one called getAliens and then this will be a function that will return from the database Aliens, so we're leveraging the database Aliens, so guess what, if we are using Aliens here, we need to import it, so we don't have it imported yet, so we need to do that. 

Let's import Aliens, now we have access to it, and then findAll, which is a function to find all the friends related to this particular database, like so. Save that. OK, so now we can go ahead and test this, so let's go into our GraphQL server, and let's make sure we also refresh it, so let's go GraphQL, like so, and we should see the query appear in here, so getAliens is there, so let's remove that. 

Let's first do the query, so let's do a query and then getAliens, like so, and Aliens doesn't require anything. But let's use Prettify. I want to show you a little shortcut, so you could have done it this way, so let's remove that, and we could have done it simply by doing getAliens, like so. If you don't want to write queries or mutations every single time, you can do a shorter way like so. Let's run it, and then we have all the aliens that sits in our database. 

The reason why we only get the ids is because we didn't enter anything. When we don't enter anything, it assumes that you at least want the ids. Let's add more stuff to it. Let's add the firstName, lastName, and then the planet, and then rerun that query again, and then we'll get all these results. If you didn't realize it yet, we're actually getting data from our SQL database now, we're not getting data from Mongo. 

If we go back to our server here, and open up our server by going to Integrated Terminal, we basically got the data that was created when the server was first created here. Raleigh, and Watsica, who's living in eius is probably the seventh item in here, so let's go in here, and you probably can see him or her somewhere in here. Or was this a second one? That's probably a second one, yeah, that was when the server was restarted, so we're good. 

OK, so this data is actually the latest data that has been created. Again, whenever we rerun our server, this force, the sync that we've done in our code actually reintroduces new data in that particular server. It's persistence but we're still forcing the data to be renewed every single time our server is started. OK, so that's from a SQL perspective. Now that we've got a simple query, which returns the list of aliens we created into our SQL database, let's move on. 

## Querying with Arguments
Before we start this video you need to add a new item with a firm mutation. Just like we did in a previous video. As I mentioned previously I had one for testing. So you'll want to add that before moving on with this video. Doing a query with an argument is as easy as passing input into a mutation like we've done in our code thus far. Let me demonstrate. So the first thing we need to do is go into our schema again. If you don't have it open, just go into schema.js and then open it and then what we'll do is change this here. So we'll change it to getOneFriend and we'll pass an id and we absolutely need an id so we need an exclamation point here. 

And then we'll return a friend. And let's make sure it's a capital F like so. So we've done a few of these with arguments. So if you take a look at all the mutations that we've done with arguments it's pretty much the same thing. So we're passing an idea here and we'll return a single Friend so let's save that and all we need to do at this point is change our resolver. So right now we have getFriend so let's completely remove that and change it to getOneFriend like so and as you saw in the past for this one we'll need root and we're passing an id and then we'll take that id and do something with it. 

And let's do a comma right away so we don't get that error. And then we'll return from our Mongo database so again like we've done in the past for creating new items we need to use a promise because we're calling into a second server so we need to have a response before we can actually resolve it. So let's go ahead and do that. Promise and we'll pass resolve and an object and again it's going to be a function and then what we'll do is use the Friends database. 

So we need find by id so basically right now in the database we are using an id to find by id. As simple as that. So we're passing inside of that function the id that we got in here and then we'll do the usual error and returning a friend like so. And everything else you can guess that it's going to be pretty much the same as what we've done below here. 

So you can literally copy and paste this line here. So on line 42. You can copy this guy here. So those two lines. And paste them here. So if there's an error, then reject the error. Else resolve the friend that we are recalling into the database. So semicolon here and we're good to go. Let's put another one there. Save all this. Let's make sure our server's running properly. So click on view, integrate a terminal. Server's running fine and actually has created new items in our sql database So when you see this it means that it's working. 

It usually restarts on its own around here and then does all this. Don't worry about the crash. That was when we were still working on our code when saved the schema. So we're good to go and let's go into graph ql. Let's refresh graph ql to make sure that we got the latest and the greatest. Check our queries, getOneFriend. Okay, we're good to go. So let's get an ID from roboT. Let's also refresh roboT. 

Click on friends, collections, friends again. And we only have one so we'll use that one to get the data so let's go ahead and click on docmen view. So we can grab the ID, copy and then go and grab ql and let's use a shorter way so getOneFriend which takes an id. Insert the id like so and then what data do we want from this guy. So we want the first name or the last name. 

Do we have a gender? I'm not so sure, but we'll get null if there's no gender. And let's run the query and there was a gender so we're good to go and we got the first name, last name based off this id. Okay, so we queried and single user with an argument and got the results so let's move on! 

## Querying with Aliases
Aliases is a feature that comes right out of the box with GraphQL, and doesn't require any coding. It is basically a way do multiple queries, and name them with anything you want to properly label them. Let me demonstrate, so right now we only have one item in our database. If we take a look at the database on Robo T, so we refresh, and go to our friends, we only have one item. So, we won't be able to do aliases if we don't have more than one item, so let's go ahead and add a few. Let's use history for that. 

Let's go to mutation, create friend, and let's recreate this guy here. So that's cool, we already have something we can recreate, and let's add a third one. Let's add "Stephanie Smoochyish," and she's a female, and she's 32, and she speaks English. Alright, so let's create this one, and we've got three items in our database. 

Let's make sure by going to Robo T, and we've got our three items here, perfect. Let's go in document mode because we'll need to copy and paste at least the IDs. Let's go and copy the first one, so this one is the one with Emmanuel, and let's create aliases. So, the way it works with aliases, it basically works the same way as we've done before with queries the only difference is that instead of running just one, you can run multiple and label them. 

So, let's go ahead and do one. We'll label the first one, "one," just for fun, and then do a colon, and then do your query, so, get one friend with the ID like so, and this is the ID, and then you do as usual so, I want to get the first name and then the last name, and then what you can do is run a second query. Let's call this one "second," and you can call it anything you want. 

It doesn't matter, and then get one friend with a second ID. So, let's go and grab a second one. Let's grab the last one, like so. Copy, colon again, and then paste, and then ask for different things in that one. So, we could ask for last name, gender, and then age for that second query. You can even call this one, second with age, be more specific. So you can be contextual in the name of your labels, and that's what an aliases is, and then run your queries. 

So, run it, and then in your results you get, well, for the first one you get first name, last name, and then on the second one with age, you get the last name, gender, and age. So, this is how easy it is to do aliases, and using aliases could be useful when the front end is calling the back end for specific users and could construct a query with a name or ID of the user to get the result with the proper label. I'm sure you can find a specific use for this feature as you explore using GraphGL with your own projects So, let's move on. 

## Querying with Fragments
Like Aliases, fragments are a neat feature that comes built in with GraphQL and is very useful when we start requesting the same data across several items. Let me demonstrate. So in this case we actually ask for different data for the two requests here. So, what we'll do is change those two and then use a fragment to ask for the same data but not have to re-type the same thing across. So, let's say for example, we had first name, last name, here as well. And then we'd have like 20 other queries in the same request. 

Then that would become very repetitive. And that's what we want to avoid with a fragment. So what we do is basically do a second line below and call this one fragment. And we call, so for example, we call this one friend fragment on friend. And this is how we type a fragment. And then what we do is specify what we want to return on this fragment. 

So, first name, last name. And then what we have to do is change on each of our queries with three dots and then say friend fragment and then do the same on the second line. So copy and paste it here. So basically what we'll do is do those two queries like we've done before and leverage your fragment to tell it exactly what we want to return on those two queries. 

And this is what a fragment is, is to avoid repetitive typing in your queries. So if we run this, like so, now we get the first name, last name, for both queries. And we've done this through a fragment. So you can see how we could use this for multiple queries. So let's say, for example, we had multiple queries with the same type of query and basically asking for the same data here, then we would get all these different queries return first name and last name. 

And you could do this for all types of items that you want to return on your queries. And if there's something or someone that doesn't have a specific item in their queries, it will return null. So, for example, email, I don't think any of them has an email. Or just the one. And then the second one will return null and this is perfectly okay. So as you can see, and very much like Aliases, the use-case for this is similar and could be used for getting multiple items and typing a lot less in your queries. 

So let's move on. 